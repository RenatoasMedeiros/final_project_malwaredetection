from flask import Flask, request, jsonify
from androguard.misc import AnalyzeAPK
import tempfile
import logging
import numpy as np
import cv2
import json
import os
from tensorflow import keras
from keras.models import load_model
from keras.preprocessing import image




app = Flask(__name__)

print("Current Working Directory:", os.getcwd())
os.chdir(os.path.dirname(os.path.abspath(__file__)))


flatten = load_model('./Flatten.hdf5', custom_objects={'loss': 'mean_squared_error'})
conv2D = load_model('../Models/CrossValidation/Conv2D_64x64/Conv2D.hdf5')
resnet50 = load_model('../Models/CrossValidation/ResNet50_64x64/Resnet50.hdf5')
#/home/renato/Documents/ProjetoFinal/Models/CrossValidation/Flatten_64x64/Flatten.hdf5



# Load dictionaries
def load_dictionaries():
    dictionaries = {}
    dict_files = [
        'API_calls_dict.json', 'malicious_apis_1.json', 'malicious_apis_2.json', 
        'benign_api_1.json', 'malicious_apis_3.json', 'malicious_apis_4.json',
        'malicious_activities.json', 'malicious_services.json', 'malicious_receivers.json',
        'malicious_intents.json', 'declared_permissions.json', 'malicious_permissions.json'
    ]
    for file_name in dict_files:
        with open(f'Dictionaries/{file_name}', 'r') as file:
            dictionaries[file_name.split('.')[0]] = json.load(file)
    return dictionaries

dictionaries = load_dictionaries()


# Your existing functions go here (e.g., OneD2TwoD_resize, dex2Image, API_calls2pixels, etc.)

# Resizing function
def OneD2TwoD_resize(image_pixels):
    h = int(len(image_pixels)**0.5)
    w = int(len(image_pixels)/h)
    
    unused_valus = len(image_pixels) - h*w
    inc = 0
    if(unused_valus != 0):
        unused_valus = len(image_pixels) - h*w
        empty_spots = w-unused_valus
        i = unused_valus
        j = unused_valus+empty_spots
        image_pixels += image_pixels[-j:-i]
        inc+=1
    
    image_pixels = np.array(image_pixels)
    twoD_image = image_pixels.reshape(h+inc,w)
    
    twoD_image = twoD_image.astype('float32')

    if(twoD_image.shape[0]>64):
        image_resized = cv2.resize(twoD_image, (64,64), interpolation = cv2.INTER_NEAREST)
    else:
        image_resized = cv2.resize(twoD_image, (64,64), interpolation = cv2.INTER_NEAREST)
    return image_resized

# Converte as propriedades das classes .dex para inteiros com range [0,255]
def dex2Image(dx,d):
    # Converte APIs para pixeis
    red_channel_stuff, API_calls_pixels = API_calls2pixels(dx)
    
    # Convert Opcodes to pixel values
    opcodes_pixls = list(opcodes2pixels(dx))
    
    blue_channel = OneD2TwoD_resize(API_calls_pixels + opcodes_pixls)

    # Convert Opcodes to pixel values
    opcodes_pixls = list(opcodes2pixels(dx))
    # blue_channel_stuff += opcodes_pixls
    
    # Extract malicious strings
    red_channel_stuff += strings2pixels(d)
    
    return blue_channel, red_channel_stuff

# Convert API calls to pixel values
def API_calls2pixels(dx):
    imprtnt_API_calls = []
    nrml_API_calls = []
    for api in dx.get_external_classes():
        api_tmp = api.get_vm_class()
        for i in api_tmp.get_methods():
            api_call = str(i).split('(')[0] # ignoring parameters and return type.
            if(api_call in dictionaries['API_calls_dict']):
                imprtnt_API_calls.append(dictionaries['API_calls_dict'][api_call])
            else:
                nrml_API_calls.append(sum(api_call.encode())%256)
    return imprtnt_API_calls, nrml_API_calls

# Convert opcodes to pixel values
def opcodes2pixels(dx):
    opcodes = []
    for method in dx.get_methods():
        if method.is_external():
            continue
        m = method.get_method()
        for ins in m.get_instructions():
            opcodes.append(ins.get_op_value())
    opcodes = list(set(opcodes))
    return opcodes

# Convert protected strings to pixel values
def strings2pixels(d):
    string_pixels = []
    all_strings = d[0].get_strings()
    
    for strng in all_strings:
        if(strng in dictionaries['API_calls_dict']):
            string_pixels.append(dictionaries['API_calls_dict'][strng])
        elif(strng in dictionaries['malicious_permissions']):
            string_pixels.append(dictionaries['malicious_permissions'][strng])
        elif(strng in dictionaries['malicious_activities']):
            string_pixels.append(dictionaries['malicious_activities'][strng])
        elif(strng in dictionaries['malicious_services']):
            string_pixels.append(dictionaries['malicious_services'][strng])
        elif(strng in dictionaries['malicious_receivers']):
            string_pixels.append(dictionaries['malicious_receivers'][strng])
        elif(strng in dictionaries['malicious_intents']):
            string_pixels.append(dictionaries['malicious_intents'][strng])
        else:
            pass
    
    return string_pixels

# Convert properties from AndroidManifest.xml file to pixel values
def manifest2Image(a):
    # Permissions
    permissions = a.get_permissions() + a.get_declared_permissions()
    imprtnt_permissions = []
    nrml_permissions = []
    for permission in permissions:
        perm = permission.split('.')[-1]
        # main key word (permission) is oftenly(always) comes at last.
        if(perm in dictionaries['malicious_permissions']):
            imprtnt_permissions.append(dictionaries['malicious_permissions'][perm])
        elif(perm in dictionaries['declared_permissions']):
            imprtnt_permissions.append(dictionaries['declared_permissions'][perm])
        else:
            nrml_permissions += list(perm.encode())
    nrml_permissions = sorted(nrml_permissions) # sort values
    imprtnt_permissions = sorted(imprtnt_permissions) # sort values 
    
    # Activities
    activities = a.get_activities()
    imprtnt_activities = []
    nrml_activities = []
    for activity in activities:
        act = activity.split('.')[-1]
        if(act in dictionaries['malicious_activities']):
            imprtnt_activities.append(dictionaries['malicious_activities'][act])
        else:
            nrml_activities += list(act.encode())
            
    # Services
    services = a.get_services()
    imprtnt_services = []
    nrml_services = []
    for service in services:
        srvc = service.split('.')[-1]
        if(srvc in dictionaries['malicious_services']):
            imprtnt_services.append(dictionaries['malicious_services'][srvc])
        else:
            nrml_services += list(srvc.encode())
            
    # receivers
    receivers = a.get_receivers()
    imprtnt_receivers = []
    nrml_receivers = []
    for receiver in receivers:
        recevr = receiver.split('.')[-1]
        if(recevr in dictionaries['malicious_receivers']):
            imprtnt_receivers.append(recevr)
        else:
            nrml_receivers += list(recevr.encode())
            
    # Providers
    providers = a.get_providers()
    nrml_providers = []
    for provider in providers:
        nrml_providers += list(provider.encode())
        
    # Intents
    imprtnt_intents = []
    nrml_intents = []
    manifest_list = {'permissions':permissions,'activity' : activities, 'service': services, 'receiver':receivers, 'provider':providers}
    intents_itemtype = {'activity' : activities, 'service': services, 'receiver':receivers, 'provider':providers}
    for itemtype, listt in intents_itemtype.items():
        for item in listt:
            try:
                for intnts in a.get_intent_filters(itemtype, item).values():
                    for intnt in intnts:
                        if(intnt in dictionaries['malicious_intents']):
                            imprtnt_intents.append(dictionaries['malicious_intents'][intnt])
                        else:
                            nrml_intents += list(intnt.encode())
            except:
                pass
    red_channel_stuff = imprtnt_permissions + imprtnt_activities + imprtnt_services + imprtnt_intents + imprtnt_receivers
    green_channel = nrml_permissions + nrml_activities + nrml_services + nrml_receivers + nrml_providers + nrml_intents
    green_channel = OneD2TwoD_resize(green_channel)
    return green_channel, red_channel_stuff

# Collecting properties (pixel values) from files, place on channel, resize the channel and merge to make an image
def apk2image(a, d, dx):
    green_channel, red_channel_stuff1 = manifest2Image(a)
    blue_channel, red_channel_stuff2 = dex2Image(dx, d)
    red_channel = red_channel_stuff1 + red_channel_stuff2
    red_channel = OneD2TwoD_resize(red_channel)
    image = cv2.merge((blue_channel, green_channel, red_channel))
    image = image.astype(dtype='uint8')
    return image


def _make_prediction(model, img_preprocessed):
    if model == "Flatten":
        prediction = np.argmax(flatten.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True), axis=-1)
        return prediction
    elif model == "Conv2D":
        prediction = np.argmax(conv2D.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True), axis=-1)
        return prediction  
    elif model == "ResNet50":
        prediction = np.argmax(resnet50.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True), axis=-1)
        return prediction
    elif model == "Combined":         
        prediction_flatten = flatten.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True)
        prediction_conv2D = conv2D.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True)
        prediction_resnet = resnet50.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True)
        prediction = np.argmax((prediction_flatten + prediction_conv2D + prediction_resnet)/3, axis=-1)
        return prediction
    else:
        return
        
def _get_class_name( prediction):
        if prediction != 4:
            return 'Malware'      
        else:
            return 'Benign'


@app.route('/upload', methods=['POST'])
def upload_apk():

    print(request)
    if 'apk' not in request.files:
        return jsonify({"error": "No file part"}), 400

    file = request.files['apk']
    
    model = request.form.get('model')
    

    print("here")
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    if file and file.filename.endswith('.apk'):
        # Pasta para salvar o APK
        save_dir = "uploaded_apks"
        os.makedirs(save_dir, exist_ok=True)
        apk_path = os.path.join(save_dir, file.filename)
        file.save(apk_path)
        
        print("Trying to generate image from APK...")
        a, d, dx = AnalyzeAPK(apk_path)
        image = apk2image(a, d, dx)
        images_dir = "images"
        os.makedirs(images_dir, exist_ok=True)
        image_path = os.path.join(images_dir, file.filename + '.jpg')
        cv2.imwrite(image_path, image)

        
        img_preprocessed = np.expand_dims(image, axis=0)
        print("\n| RUNTIME |  Finished PreProcessing\nGoing to Predict the Image\n")
        prediction = _make_prediction(model, img_preprocessed)
        print("\n| RUNTIME |  FInished Prediction :" , prediction)

        if prediction is None:
            return jsonify({"error": "A problem as occured while applying the model"}), 400
        
        classification =  _get_class_name(prediction)
        print("\n| RUNTIME |  FInished Prediction :" , classification)
        return jsonify({"message": "File analyzed successfully", "classification": classification, "model": model}), 200

    return jsonify({"error": "Invalid file type"}), 400

# Endpoint para obter a lista de modelos!
@app.route('/models', methods=['GET'])
def get_models():
    try:
        models_dir = "../Models/CrossValidation"
        models = [name for name in os.listdir(models_dir) if os.path.isdir(os.path.join(models_dir, name))]
        return jsonify({"models": models}), 200
    except Exception as e:
        print(f"Error retrieving models: {str(e)}")
        return jsonify({"error": str(e)}), 500



if __name__ == '__main__':
    app.run()