import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.colors import ListedColormap


def load_csv_files(folder_path):
    csv_files = [file for file in os.listdir(folder_path) if file.endswith('.csv')]
    dataframes = [pd.read_csv(os.path.join(folder_path, file)) for file in csv_files]
    for df, file in zip(dataframes, csv_files):
        df.name = file
    return dataframes


def get_common_columns(dataframes):
    common_columns = set(dataframes[0].columns)
    for df in dataframes[1:]:
        common_columns.intersection_update(df.columns)
    if 'epoch_time' in common_columns:
        return list(common_columns), True
    else:
        return list(common_columns), False



def identify_validation_method(df):
    max_epoch = df['epoch'].max()
    if max_epoch == len(df):  # Supondo que os epochs começam de 1 e vão até max_epoch
        return 'Holdout'
    else:
        return 'Cross-validation'


def display_columns_table(common_columns):
    print("\nColunas comuns disponíveis nos arquivos CSV:")
    max_col_length = max(len(col) for col in common_columns)
    print("+{:-<{width}}+".format('', width=max_col_length + 4))
    for idx, col in enumerate(common_columns, 1):
        print("| {:<3} {:<{width}} |".format(idx, col, width=max_col_length))
    print("+{:-<{width}}+".format('', width=max_col_length + 4))


def ask_xy_axis_question(common_columns):
    if 'epoch' in common_columns and 'val_accuracy' in common_columns:
        answer = input("Deseja que o eixo X seja 'epoch' e o eixo Y seja 'Validation Accuracy'? (s/n): ").strip().lower()
        if answer == 's':
            return 'epoch', 'val_accuracy'
    return None, None


def select_columns(common_columns):
    print("\nSelecione as colunas para os eixos X e Y:")
    display_columns_table(common_columns)
    
    x_idx = int(input("Selecione o número para o eixo X: ")) - 1
    y_idx = int(input("Selecione o número para o eixo Y: ")) - 1
    
    x_col = common_columns[x_idx]
    y_col = common_columns[y_idx]
    
    return x_col, y_col


def plot_data(dataframes, x_col, y_col, best_epoch, worst_epoch, 
              best_model_name, worst_model_name, best_model_color, 
              show_best, show_worst, show_all_legend, goal_value=None):
    plt.figure(figsize=(10, 6))

    if goal_value is not None:
        plt.axhline(y=goal_value, color='g', linestyle='--', label=f'Objetivo: {goal_value}')

    intersection_x_values = []
    intersection_y_values = []
    intersection_times = []
    intersection_labels = []

    crossval_dfs = [df for df in dataframes if identify_validation_method(df) == 'Cross-validation']
    holdout_dfs = [df for df in dataframes if identify_validation_method(df) == 'Holdout']

    cmap = plt.cm.tab10
    colors = cmap(np.linspace(0, 1, len(crossval_dfs) + len(holdout_dfs)))

    handles = []
    labels = []

    # Plotting Cross-validation files
    for idx, df in enumerate(crossval_dfs):
        all_epochs = np.unique(df[x_col].values)
        average_values = []

        for epoch in all_epochs:
            epoch_values = df[df[x_col] == epoch][y_col].values
            average_epoch_value = np.mean(epoch_values)
            average_values.append(average_epoch_value)

        non_empty_average_values = [av for av in average_values if not np.isnan(av)]
        line_color = colors[idx]

        handle, = plt.plot(all_epochs, average_values, label=f'{df.name} (Média)', linewidth=2, color=line_color)
        handles.append(handle)
        labels.append(f'{df.name} (Média)')

        if goal_value is not None:
            for i in range(len(all_epochs) - 1):
                if (average_values[i] <= goal_value <= average_values[i + 1]) or (average_values[i] >= goal_value >= average_values[i + 1]):
                    x_intercept = all_epochs[i] + ((goal_value - average_values[i]) * (all_epochs[i + 1] - all_epochs[i])) / (average_values[i + 1] - average_values[i])
                    intersection_x_values.append(x_intercept)
                    intersection_y_values.append(goal_value)
                    intersection_times.append(df['epoch_time'].values[-1] if df['epoch_time'].values[-1] >= goal_value else 0)
                    intersection_labels.append(f'{df.name}: { goal_value*100 }% -> {intersection_times[-1]:.2f}s')
                    break

    # Plotting Holdout files
    for idx, df in enumerate(holdout_dfs, start=len(crossval_dfs)):
        line_color = colors[idx]
        handle, = plt.plot(df[x_col], df[y_col], label=f'{df.name}', linewidth=2, color=line_color)
        handles.append(handle)
        labels.append(f'{df.name}')

        if goal_value is not None:
            for i in range(len(df[x_col]) - 1):
                if (df[y_col].values[i] <= goal_value <= df[y_col].values[i + 1]) or (df[y_col].values[i] >= goal_value >= df[y_col].values[i + 1]):
                    x_intercept = df[x_col].values[i] + ((goal_value - df[y_col].values[i]) * (df[x_col].values[i + 1] - df[x_col].values[i])) / (df[y_col].values[i + 1] - df[y_col].values[i])
                    intersection_x_values.append(x_intercept)
                    intersection_y_values.append(goal_value)
                    intersection_times.append(df['epoch_time'].values[-1] if df['epoch_time'].values[-1] >= goal_value else 0)
                    intersection_labels.append(f'{df.name}: { goal_value*100 }% -> {intersection_times[-1]:.2f}s')
                    break

    plt.scatter(intersection_x_values, intersection_y_values, color='red', marker='o', zorder=5)

    best_handle = None
    worst_handle = None

    if show_best:
        if non_empty_average_values:
            best_average_value = np.max(non_empty_average_values)
            best_handle = plt.axvline(x=best_epoch, color='r', linestyle='--')
            handles.append(best_handle)
            labels.append(f'Maiores Resultados: 0.902 ({best_model_name})')

    if show_worst:
        worst_average_value = np.min(non_empty_average_values)
        worst_handle = plt.axvline(x=worst_epoch, color='b', linestyle='--')
        handles.append(worst_handle)
        labels.append(f'Menores Resultados: {worst_average_value:.3f} ({worst_model_name})')

    plt.xlabel(x_col)
    plt.ylabel(y_col)

    if show_all_legend:
        for i in range(min(len(intersection_labels), 3)):
            handles.append(plt.Line2D([], [], color='red', marker='o', linestyle='None'))
            labels.append(intersection_labels[i])
        plt.legend(handles, labels, loc='lower right')
    else:
        limited_handles = []
        limited_labels = []

        if best_handle:
            limited_handles.append(best_handle)
            limited_labels.append(f'Melhores Resultados: 0.902 ({best_model_name})')

        if worst_handle:
            limited_handles.append(worst_handle)
            limited_labels.append(f'Piores Resultados: {worst_average_value:.3f} ({worst_model_name})')

        if intersection_labels:
            for i in range(min(len(intersection_labels), 3)):
                limited_handles.append(plt.Line2D([], [], color='red', marker='o', linestyle='None'))
                limited_labels.append(intersection_labels[i])

        plt.legend(limited_handles, limited_labels, loc='lower right')

    plt.tight_layout(rect=[0, 0.2, 1, 1])
    plt.show()



def get_best_and_worst_model(dataframes, y_col):
    best_model = None
    worst_model = None
    best_average_value = -float('inf')
    worst_average_value = float('inf')
    best_epoch = None
    worst_epoch = None
    
    for df in dataframes:
        validation_method = identify_validation_method(df)
        
        if validation_method == 'Cross-validation':
            y_values = df[y_col].values
            sum_values = np.sum(y_values)
            n_folds = len(y_values)
            average_value = np.mean(y_values)  # Calculando a média em vez da mediana
            
            # Print the sum, number of folds, and average for each file
            print(f"File {df.name}, Media = {sum_values} / {n_folds} = {average_value:.3f}")
        
        else:  # Holdout method
            y_values = df[y_col].values
            max_value = np.max(y_values)
            sum_values = np.sum(y_values)
            n_folds = len(y_values)
            average_value = max_value  # Para holdout, consideramos o maior valor
            print(f"File {df.name}, Max Value = {max_value}")
        
        if average_value > best_average_value:
            best_average_value = average_value
            best_model = df
            best_epoch = df.loc[np.argmax(df[y_col].values), 'epoch']
        if average_value < worst_average_value:
            worst_average_value = average_value
            worst_model = df
            worst_epoch = df.loc[np.argmin(df[y_col].values), 'epoch']
    
    best_model_color = None
    if best_model is not None:
        for idx, df in enumerate(dataframes):
            if df.name == best_model.name:
                best_model_color = plt.cm.tab10(idx / len(dataframes))
                break
    
    return best_epoch, worst_epoch, best_model.name if best_model is not None else None, worst_model.name if worst_model is not None else None, best_model_color


def main(folder_path):
    print(f"Carregando arquivos CSV da pasta: {folder_path}")
    dataframes = load_csv_files(folder_path)
    if not dataframes:
        print("Nenhum arquivo CSV encontrado na pasta especificada.")
        return

    common_columns, has_epoch_time = get_common_columns(dataframes)
    if not common_columns:
        print("Nenhuma coluna comum encontrada nos arquivos CSV.")
        return

    x_col, y_col = ask_xy_axis_question(common_columns)

    if x_col is None or y_col is None:
        x_col, y_col = select_columns(common_columns)

    best_epoch, worst_epoch, best_model_name, worst_model_name, best_model_color = get_best_and_worst_model(dataframes, y_col)
    # print("Melhor Epoch: ", best_epoch)
    # print("Pior Epoch: ", worst_epoch)

    show_best = input("Deseja exibir uma linha para os MAIORES resultados? (s/n): ").strip().lower() == 's'
    show_worst = input("Deseja exibir uma linha para os MENORES resultados? (s/n): ").strip().lower() == 's'
    show_all_legend = input("Deseja exibir todos os ficheiros CSVs na legenda do gráfico? (s/n): ").strip().lower() == 's'

    if has_epoch_time:
        goal_y_axis = input("Deseja definir um valor de objetivo no eixo Y para mostrar intercessões? (s/n): ").strip().lower() == 's'
        if goal_y_axis:
            goal_value = float(input("Digite o valor desejado no eixo Y para mostrar intercessões: "))
            plot_data(dataframes, x_col, y_col, best_epoch, worst_epoch, best_model_name, worst_model_name, best_model_color, show_best, show_worst, show_all_legend, goal_value)
        else:
            plot_data(dataframes, x_col, y_col, best_epoch, worst_epoch, best_model_name, worst_model_name, best_model_color, show_best, show_worst, show_all_legend)
    else:
        plot_data(dataframes, x_col, y_col, best_epoch, worst_epoch, best_model_name, worst_model_name, best_model_color, show_best, show_worst, show_all_legend)


if __name__ == "__main__":
    folder_path = input("Informe o path da pasta contendo os arquivos CSV (path absoluto): ")
    main(folder_path)
