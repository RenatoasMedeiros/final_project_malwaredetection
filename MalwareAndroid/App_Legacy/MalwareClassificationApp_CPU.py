#!/usr/bin/env python
# coding: utf-8

# In[1]:


import numpy as np
import json
import cv2
import os
import customtkinter as ctk
import tkinter as tk
import matplotlib.pyplot as plt
import tensorflow as tf 
import threading

from tkinter import filedialog, Listbox, font
from os.path import basename
from tkinter import messagebox
from androguard.misc import AnalyzeAPK
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image


# In[2]:


class MalwareDetectionApp:
    def __init__(self):
        
        #
        #
        #   Initializing Necessary Variables And Attributes -----------------------------------------------------------    
        #
        #
        
        # Setting color scheme
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("dark-blue")
        self.filepath = ""
        self.message_list = []
        self.model_list = ["Flatten", "Conv2D", "ResNet50", "Combined"]        
        
        #
        #
        #   Main Frame ------------------------------------------------------------------------------------------------              
        #
        #
   
        # Create the main window
        self.root = ctk.CTk()
        self.root.geometry("800x500") # WIDTHxHEIGHT
        self.root.resizable(False, False) # Disable the functionality to resize the window
        self.root.title("Malware detection and classification app")

        # Create the main frame to hold the widgets
        self.main_frame = ctk.CTkFrame(master=self.root, fg_color="transparent")
        self.main_frame.pack(pady=20, padx=20, ipady=10, ipadx=10, fill="both", expand=True)

        #
        #
        #   File / Folder Selection Subframe -----------------------------------------------------------------------------------               
        #
        #
        
        # Create the frame for file selection
        self.file_selection_subframe = ctk.CTkFrame(master=self.main_frame)
        self.file_selection_subframe.pack(pady=5, padx=5, ipady=15, ipadx=15, side=ctk.TOP, fill="x", expand=True, anchor="n")

        # Create a label for file selection
        self.file_label = ctk.CTkLabel(master=self.file_selection_subframe, text="Select File/Folder", font=("Roboto", 18), justify="center")
        self.file_label.pack(pady=5, padx=5, side=ctk.TOP)
        
        # Create a button to open the file dialog
        self.file_button = ctk.CTkButton(master=self.file_selection_subframe, text="Open File", width=100, command=self._open_file_dialog)
        self.file_button.pack(pady=12, padx=18, side=ctk.LEFT)
        
        # Create a button to open the folder dialog
        self.folder_button = ctk.CTkButton(master=self.file_selection_subframe, text="Open Folder",  width=100, command=self._open_folder_dialog)
        self.folder_button.pack(pady=12, padx=4, side=ctk.LEFT)
        
        # Create a text entry widget to display and edit the file path
        self.filepath_entry = ctk.CTkEntry(master=self.file_selection_subframe)
        self.filepath_entry.pack(pady=5, padx=12, side=ctk.RIGHT, fill="x", expand=True)
        
        #
        #
        #   Save File Subframe ----------------------------------------------------------------------------------------           
        #
        #
        
        # Create the frame for saving the file
        self.save_subframe = ctk.CTkFrame(master=self.main_frame)
        self.save_subframe.pack(pady=5, padx=5, ipady=15, ipadx=15, side=ctk.BOTTOM, fill="x", anchor="s") # , expand=True

        # Create a label for saving the file
        self.save_label = ctk.CTkLabel(master=self.save_subframe, text="Save Results", font=("Roboto", 18), justify="center")
        self.save_label.pack(pady=5, padx=5, side=ctk.TOP)

        # Create an entry widget for defining the file path and extension
        self.save_entry = ctk.CTkEntry(master=self.save_subframe)
        self.save_entry.pack(pady=12, padx=13, side=ctk.LEFT, fill="x", expand=True)
        
        # Create the save button
        self.save_button = ctk.CTkButton(master=self.save_subframe, text="Save", width=100, command=self._save_file)
        self.save_button.pack(pady=4, padx=18, side=ctk.RIGHT)
               
        # Create the save as button
        self.save_as_button = ctk.CTkButton(master=self.save_subframe, text="Save as", width=100, command=self._save_file_as)
        self.save_as_button.pack(pady=4, padx=4, side=ctk.RIGHT)
        
        #
        #
        #   Model Selection Subframe ----------------------------------------------------------------------------------       
        #
        #
        
        # Create the frame for model selection
        self.model_selection_subframe = ctk.CTkFrame(master=self.main_frame)
        self.model_selection_subframe.pack(pady=5, padx=5, ipady=15, ipadx=15, side=ctk.LEFT, fill="y") # 

        # Create a label for model selection
        self.model_label = ctk.CTkLabel(master=self.model_selection_subframe, text="Select Model", font=("Roboto", 18), justify="center")
        self.model_label.pack(pady=5, padx=5, side=ctk.TOP)

        # Create a combo box with the models avaiable
        self.model_optionmenu = ctk.CTkOptionMenu(master=self.model_selection_subframe, values=self.model_list)
        self.model_optionmenu.pack(pady=25, padx=4, anchor="center")

        # Create a button to use the model to classify the file given
        self.model_button = ctk.CTkButton(master=self.model_selection_subframe, text="Apply Model", command=self._apply_model)
        self.model_button.pack(pady=7, padx=4, anchor="center")
        
        # Create a label for model selection
        self.model_warning_label = ctk.CTkLabel(master=self.model_selection_subframe, text="(this process might take a while)", font=("Roboto", 10), justify="center")
        self.model_warning_label.pack(padx=5, side=ctk.TOP)
        
        #
        #
        #   Result Subframe -------------------------------------------------------------------------------------------       
        #
        #
        
        # Create the frame for model selection
        self.result_subframe = ctk.CTkFrame(master=self.main_frame)
        self.result_subframe.pack(pady=5, padx=5, ipady=15, ipadx=15, fill="x") #, expand=True, side=ctk.RIGHT
        
        self.result_aux_subframe = ctk.CTkFrame(master=self.result_subframe, fg_color="transparent")
        self.result_aux_subframe.pack(pady=0, padx=0, ipady=0, ipadx=0, side=ctk.TOP, fill="x")
        
        self.result_label_xpadding = self.result_subframe.cget("width") * 0.7
        
        # Create a button to use clear the listbox
        self.result_button = ctk.CTkButton(master=self.result_aux_subframe, text="Clear", width=60, command=self._clear_output)
        self.result_button.pack(pady=5, padx=15, side=tk.RIGHT) 
        
        # Create a label for the result showing frame
        self.result_label = ctk.CTkLabel(master=self.result_aux_subframe, text="Classification", font=("Roboto", 18), justify="center")
        self.result_label.pack(pady=5, padx=self.result_label_xpadding, side=tk.RIGHT, fill="x") # 
        #140
        # Create a listbox to show the results
        self.result_listbox = Listbox(master=self.result_subframe, font=("Roboto", 11))
        self.result_listbox.pack(pady=15, padx=15, fill="both", expand=True, anchor="center")
        
        # Bind the adjust_line_length function to the Listbox resize event
        self.result_listbox.bind("<Configure>", self._adjust_line_length)
        
        #
        #
        #   Loading Dictionaries --------------------------------------------------------------------------------------       
        #
        #
        
        with open('./dictionaries/API_calls_dict.json', 'r') as file:
            self.api_calls_dict = json.load(file)
            file.close()

        with open('./dictionaries/malicious_apis_1.json', 'r') as file:
            self.malicious_apis_1 = json.load(file)
            file.close()

        with open('./dictionaries/malicious_apis_2.json', 'r') as file:
            self.malicious_apis_2 = json.load(file)
            file.close()

        with open('./dictionaries/benign_api_1.json', 'r') as file:
            self.benign_api_1 = json.load(file)
            file.close()

        with open('./dictionaries/malicious_apis_3.json', 'r') as file:
            self.malicious_apis_3 = json.load(file)
            file.close()

        with open('./dictionaries/malicious_apis_4.json', 'r') as file:
            self.malicious_apis_4 = json.load(file)
            file.close()

        with open('./dictionaries/malicous_activities.json', 'r') as file:
            self.malicous_activities = json.load(file)
            file.close()

        with open('./dictionaries/malicious_services.json', 'r') as file:
            self.malicious_services = json.load(file)
            file.close()

        with open('./dictionaries/malicious_recivers.json', 'r') as file:
            self.malicious_recivers = json.load(file)
            file.close()

        with open('./dictionaries/malicious_intents.json', 'r') as file:
            self.malicious_intents = json.load(file)
            file.close()

        with open('./dictionaries/decleared_permissions.json', 'r') as file:
            self.decleared_permissions = json.load(file)
            file.close()

        with open('./dictionaries/malicious_permissions.json', 'r') as file:
            self.malicious_permissions = json.load(file)
            file.close()
            
        #
        #
        #   Loading Models From The HDF5 Files ------------------------------------------------------------------------    
        #
        #
        with tf.device("/cpu:0"):
            self.flatten = load_model('./models/flatten.hdf5')
            self.conv2D = load_model('./models/conv2D.hdf5')
            self.resnet50 = load_model('./models/resnet50.hdf5')   

    #
    #
    #   Defining Necessary Methods ------------------------------------------------------------------------------------     
    #
    #
    
    def run(self):
        # Start the main application loop
        self.root.mainloop()
    
    #
    #
    #   App Object Related  Methods -----------------------------------------------------------------------------------    
    #
    # 
    
    # Selecting file and updating entry
    def _open_file_dialog(self, event=None):
        filepath = filedialog.askopenfilename(
            initialdir="/",
            title="Select APK File",
            filetypes=(("APK files", "*.apk"), ("All files", "*.*"))
        )
        if filepath:
            self.filepath_entry.delete(0, "end")  # Clear the current entry
            self.filepath_entry.insert(0, filepath)  # Insert the selected file path
    
    # Selecting folder and updating entry
    def _open_folder_dialog(self, event=None):
        folderpath = filedialog.askdirectory(
            initialdir="/",
            title="Select Folder"
        )
        if folderpath:
            self.filepath_entry.delete(0, "end")  # Clear the current entry
            self.filepath_entry.insert(0, folderpath)  # Insert the selected folder path
    
    # Generate the image and make the prediction based on the file/folder and model choosen
    def _apply_model(self, event=None):    
        path = self.filepath_entry.get()
        model = self.model_optionmenu.get()
                
        if os.path.isfile(path):
            computation_thread = threading.Thread(target=self._classificate_single_image, args=(path, model))
            computation_thread.start()
        elif os.path.isdir(path):
            computation_thread = threading.Thread(target=self._classificate_dir, args=(path, model))
            computation_thread.start()
        else:
            self._show_warning("No such file or directory")
            return
    
    # Generates the image from a single file and applies the model 
    def _classificate_single_image(self, path, model):     
        image = self._generate_image(path)

        if image is None:
            self._show_warning("Unable to create image from file " + basename(path) + "\nPlease check if file is not corrupted")
            return

        img_preprocessed = np.expand_dims(image, axis=0)
        prediction = self._make_prediction(model, img_preprocessed)

        if prediction is None:
            self._show_warning("A problem as occured while applying the model")
            return

        self._print_output(path, model, prediction)
        self.result_listbox.insert(tk.END, "DONE") 
        self.result_listbox.insert(tk.END, "-" * 168)

        
    # Generates the images from all files inside a folder and classifies them
    def _classificate_dir(self, path, model):     
        generation_problems = []
        prediction_problems = []
        for file in os.listdir(path):
            filepath = os.path.join(path, file)
            image = self._generate_image(filepath)
            if image is None:
                generation_problems.append(file)
                continue

            img_preprocessed = np.expand_dims(image, axis=0)
            prediction = self._make_prediction(model, img_preprocessed)  

            if prediction is None:
                prediction_problems.append(file)
                continue

            self._print_output(file, model, prediction)
        self.result_listbox.insert(tk.END, "DONE") 
        self.result_listbox.insert(tk.END, "-" * 168)
        if len(generation_problems) != 0 or len(prediction_problems) != 0:
            total = len(generation_problems) + len(prediction_problems)
            error_message = "A total of " + str(total) + " problems occured.\n\nProblems while generating images:\n" + "".join(generation_problems) + "\n\nProblems while making prediction:\n" + "".join(prediction_problems)
            self._show_warning(error_message)
        
  
    # Checks the model selected and makes the prediction
    def _make_prediction(self, model, img_preprocessed):
        with tf.device("/cpu:0"):
            if model == "Flatten":
                prediction = np.argmax(self.flatten.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True), axis=-1)
                return prediction
            elif model == "Conv2D":
                prediction = np.argmax(self.conv2D.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True), axis=-1)
                return prediction  
            elif model == "ResNet50":
                prediction = np.argmax(self.resnet50.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True), axis=-1)
                return prediction
            elif model == "Combined":         
                prediction_flatten = self.flatten.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True)
                prediction_conv2D = self.conv2D.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True)
                prediction_resnet = self.resnet50.predict(img_preprocessed, verbose=0, workers=4, use_multiprocessing=True)
                prediction = np.argmax((prediction_flatten + prediction_conv2D + prediction_resnet)/3, axis=-1)
                return prediction
            else:
                return
        
    # Defines the path where the file should be saved and then saves it
    def _save_file_as(self, event=None):
        self.filepath = filedialog.asksaveasfilename(
            initialdir="/",
            initialfile="Classification_Results.txt",
            title="Save As",
            filetypes=(("Text files", "*.txt"), ("All files", "*.*"))
        )
        if self.filepath:
            #deleting and adding new filepath the entry
            self.save_entry.delete(0, tk.END)
            self.save_entry.insert(0, self.filepath)

            with open(self.filepath, "w") as file:
                file.writelines(self.message_list)
                print("File saved successfully.")
    
    # If a path to save the file is already given simply saves the file, if not calls '_save_file_as'
    def _save_file(self, event=None):    
        if self.filepath:
            with open(self.filepath, "w") as file:
                file.writelines(self.message_list)
                print("File saved successfully.")
            return
        
        self._save_file_as() 
    
    # Prints output in listbox and adds it to the message_list to be saved in a file later
    def _print_output(self, path, model, prediction):
        file_message = "File: '" + basename(path) + "'"    
        prediction_message = "Model: " + model + " | Prediction: " + self._get_class_name(prediction[0])
        self.message_list.append(file_message + '\n' + prediction_message + '\n' + '-' * 118 + '\n')
        
        self.result_listbox.insert(tk.END, file_message)
        self.result_listbox.insert(tk.END, prediction_message) 
        self.result_listbox.insert(tk.END, '-' * 168)
        
    # Opens a pop-up with the message given
    def _show_warning(self, message):
        messagebox.showwarning("Warning", message)
    
    # Clear output from listbox and message_list
    def _clear_output(self):
        self.result_listbox.delete(0, tk.END)
        self.message_list = []

    #
    #
    #   Image Generation and Classification Methods -------------------------------------------------------------------    
    #
    #   
    
    #Resizing all channels to a fixed shape by using Nearest neighbour interpolation
    def _oneD2TwoD_resize(self, image_pixels):
        h = int(len(image_pixels)**0.5)
        w = int(len(image_pixels)/h)

        unused_valus = len(image_pixels) - h*w
        inc = 0
        if(unused_valus != 0):
            unused_valus = len(image_pixels) - h*w
            empty_spots = w-unused_valus
            i = unused_valus
            j = unused_valus+empty_spots
            image_pixels += image_pixels[-j:-i]
            inc+=1

        image_pixels = np.array(image_pixels)
        twoD_image = image_pixels.reshape(h+inc,w)

        twoD_image = twoD_image.astype('float32')

        if(twoD_image.shape[0]>64):
            image_resized = cv2.resize(twoD_image, (64,64), interpolation = cv2.INTER_NEAREST)# INTER_LINEAR
        else:
            image_resized = cv2.resize(twoD_image, (64,64), interpolation = cv2.INTER_NEAREST)# INTER_LINEAR        
        return image_resized
    
    #Convert properties from classes.dex file to integers (pixel values) in range [0,255]
    def _dex2Image(self, dx, d):
        #Convert APIs to pixel values
        red_channel_stuff, api_calls_pixels = self._api_calls2pixels(dx)
        
        #Convert Opcodes to pixel values
        opcodes_pixls = list(self._opcodes2pixels(dx))

        blue_channel = self._oneD2TwoD_resize(api_calls_pixels + opcodes_pixls)  #[api_calls_pixels + opcodes_pixls][0]

        #Extract malicious strings
        red_channel_stuff += self._strings2pixels(d)
        return blue_channel, red_channel_stuff

    #Convert API calls to pixel values
    def _api_calls2pixels(self, dx):
        imprtnt_API_calls = []
        nrml_API_calls = []
        for api in dx.get_external_classes():
            api_tmp = api.get_vm_class()
            for i in api_tmp.get_methods():
                api_call = str(i).split('(')[0] # ignoring parameters and return type.
                if(api_call in self.api_calls_dict):
                    imprtnt_API_calls.append(self.api_calls_dict[api_call])
                else:
                    nrml_API_calls.append(sum(api_call.encode())%256)       
        return imprtnt_API_calls, nrml_API_calls

    #Convert opcodes to pixel values
    def _opcodes2pixels(self, dx):
        opcodes = []
        for method in dx.get_methods():
            if method.is_external():
                continue
            m = method.get_method()
            for ins in m.get_instructions():
                opcodes.append(ins.get_op_value())
        opcodes = list(set(opcodes))
        return opcodes

    #Convert protected strings to pixel values
    def _strings2pixels(self, d):
        string_pixels = []
        all_strings = d[0].get_strings()

        for strng in all_strings:
            if(strng in self.api_calls_dict):
                string_pixels.append(self.api_calls_dict[strng])
            elif(strng in self.malicious_permissions):
                string_pixels.append(self.malicious_permissions[strng])
            elif(strng in self.malicous_activities):
                string_pixels.append(self.malicous_activities[strng])
            elif(strng in self.malicious_services):
                string_pixels.append(self.malicious_services[strng])
            elif(strng in self.malicious_recivers):
                string_pixels.append(self.malicious_recivers[strng])
            elif(strng in self.malicious_intents):
                string_pixels.append(self.malicious_intents[strng])
            else:
                pass
        return string_pixels
    
    #Convert properties from AndroidMAnifest.xml file to pixel values
    def _manifest2Image(self, a):
        #Permissions
        permissions = a.get_permissions() + a.get_declared_permissions()
        imprtnt_permissions = []
        nrml_permissions = []
        for permission in permissions:
            perm = permission.split('.')[-1]
            # main key word (permission) is oftenly(always) comes at last.
            if(perm in self.malicious_permissions):
                imprtnt_permissions.append(self.malicious_permissions[perm])
            elif(perm in self.decleared_permissions):
                imprtnt_permissions.append(self.decleared_permissions[perm])
            else:
                nrml_permissions += list(perm.encode())
        nrml_permissions = sorted(nrml_permissions)
        imprtnt_permissions = sorted(imprtnt_permissions)
        
        #Activities
        activities = a.get_activities()
        imprtnt_activities = []
        nrml_activities = []
        for activity in activities:
            act = activity.split('.')[-1]
            if(act in self.malicous_activities):
                imprtnt_activities.append(self.malicous_activities[act])
            else:
                nrml_activities += list(act.encode())

        #Services
        services = a.get_services()
        imprtnt_services = []
        nrml_services = []
        for service in services:
            srvc = service.split('.')[-1]
            if(srvc in self.malicious_services):
                imprtnt_services.append(self.malicious_services[srvc])
            else:
                nrml_services += list(srvc.encode())

        #Recivers
        receivers = a.get_receivers()
        imprtnt_receivers = []
        nrml_receivers = []
        for receiver in receivers:
            recevr = receiver.split('.')[-1]
            if(recevr in self.malicious_recivers):
                imprtnt_receivers.append(recevr)
            else:
                nrml_receivers += list(recevr.encode())

        #Providers
        providers = a.get_providers()
        nrml_providers = []
        for provider in providers:
            nrml_providers += list(provider.encode())

        #Intents
        imprtnt_intents = []
        nrml_intents = []
        manifest_list = {'permissions':permissions,'activity' : activities, 'service': services, 'receiver':receivers, 'provider':providers}
        intents_itemtype = {'activity' : activities, 'service': services, 'receiver':receivers, 'provider':providers}
        for itemtype, listt in intents_itemtype.items():
            for item in listt:
                try:
                    for intnts in a.get_intent_filters(itemtype, item).values():
                        for intnt in intnts:
                            if(intnt in self.malicious_intents):
                                imprtnt_intents.append(self.malicious_intents[intnt])
                            else:
                                nrml_intents += list(intnt.encode())
                except:
                    pass
        red_channel_stuff = imprtnt_permissions + imprtnt_activities + imprtnt_services + imprtnt_intents + imprtnt_receivers
        green_channel = nrml_permissions + nrml_activities + nrml_services + nrml_receivers + nrml_providers + nrml_intents
        green_channel = self._oneD2TwoD_resize(green_channel)
        return green_channel, red_channel_stuff
    
    #Collecting properties (pixel values) from files, place on channel, resize the channel and merge to make an image
    def _apk2image(self, a, d, dx):    
        green_channel, red_channel_stuff1 = self._manifest2Image(a)   
        
        blue_channel, red_channel_stuff2 = self._dex2Image(dx, d)
        
        red_channel = red_channel_stuff1 + red_channel_stuff2       
        red_channel = self._oneD2TwoD_resize(red_channel)
        
        image = cv2.merge((blue_channel, green_channel, red_channel))
        image = image.astype(dtype='uint8')
        return image
       
    def _generate_image(self, filepath):
        try:
            #Androguard
            a,d,dx = AnalyzeAPK(filepath)
            
            img = self._apk2image(a,d,dx)

            return img 

        except:
            return  
    
    # Assign the class
    def _get_class_name(self, prediction):
        if prediction == 0:
            return 'Adware'
        elif prediction == 1:
            return 'Banking'   
        elif prediction == 2:
            return 'Riskware'      
        elif prediction == 3:
            return 'SMS Malware'         
        elif prediction == 4:
            return 'Benign'
        else:
            return 'Error getting class name' 
    
    #
    #
    #   Other Methods -------------------------------------------------------------------------------------------------       
    #
    #   

    def _adjust_line_length(self, event):
        # Retrieve the available width in the Listbox
        available_width = self.result_listbox.winfo_width()

        # Adjust the length of each line
        for i in range(self.result_listbox.size()):
            line = self.result_listbox.get(i)
            new_line = ""
            current_width = 0

            for word in line.split():
                word_width = self.result_listbox.font.measure(word + " ")
                if current_width + word_width > available_width:
                    self.result_listbox.insert(i, new_line.strip())
                    new_line = ""
                    current_width = 0
                new_line += word + " "
                current_width += word_width

            self.result_listbox.delete(i)
            self.result_listbox.insert(i, new_line.strip())


# In[3]:


# Create an instance of the MalwareDetectionApp class
app = MalwareDetectionApp()

# Run the application
app.run()


# In[ ]:




